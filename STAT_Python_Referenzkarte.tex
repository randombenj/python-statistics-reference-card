\documentclass{article}

\usepackage[a4paper,left=1cm,right=1cm,top=15mm,bottom=1cm,headsep=5mm,landscape]{geometry}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{lipsum}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{tcolorbox}
\usepackage{tikz}

\definecolor{headertext}{rgb}{0.5,0.5,0.5}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\lhead{\color{headertext} PYTHON - REFERENZKARTE}
\chead{\color{headertext} STATISTICS FOR DATA SCIENCE}
\rhead{\color{headertext} SEITE \thepage}

\setlength{\parindent}{0cm}
\newminted[python]{python}{}
\newmintinline{python}{breaklines,tabsize=2}

\begin{document}
\begin{multicols*}{3}

\subsection*{Häufig verwendete Bibliotheken}
\begin{python}
import matplotlib.pyplot as plt
import scipy.stats as st
import seaborn as sns
import pandas as pd
import numpy as np
\end{python}

\subsection*{Hilfe anzeigen}
\pythoninline{help(np.random)} \\
Hilfetext eines Packages anzeigen \\

\pythoninline{help(np.random.choice)} \\
Hilfetext einer Funktion anzeigen

\subsection*{Numpy Basics}
\pythoninline{np.e}: Konstante mit Wert von $e$ \\
\pythoninline{np.pi}:  Konstante mit Wert von $\pi$ \\
\pythoninline{np.sqrt(2)}: Wurzel von Zahl berechnen \\
\pythoninline{np.square(2)}: Quadrat von Zahl berechen \\
\pythoninline{np.abs(-45)}: Absolutwert einer Zahl berechnen \\
\pythoninline{np.round(2.35, x)}: Zahl auf \textit{x} Nachkomastellen runden \\
\pythoninline{np.log(100)}: Natürlicher Logarithmus berechnen \\
\pythoninline{np.log10(100)}: Logarithmus mit Basis 10 berechnen \\
\pythoninline{np.prod(arr)}: Produkt der Zahlen von \textit{arr}

\subsection*{Numpy Arrays}
\pythoninline{arr = np.array([2, 1, 4, 5, -8, 10])} \\
Numpy-Array erzeugen \\

\pythoninline{np.linspace(start=1, stop=2, num=4)} \\
\textit{num} Zahlen zwischen \textit{start} und \textit{stop} \\
In diesem Beispiel: [1.0, 1.333, 1.666, 2.0] \\

\pythoninline{np.arange(start=1, stop=4, step=.6)} \\
Zahlen von \textit{start} bis \textit{stop} mit inkrement \textit{step} \\
In diesem Beispiel: [1.0, 1.6, 2.2, 2.8, 3.4] \\

\pythoninline{new_arr = arr.reshape((n, m))} \\
1-dimensionales Array in 2-dimensionales umwandeln \\
Neues Array hat \textit{n} Zeilen mit je \textit{m} Elementen \\

\pythoninline{np.percentile(arr, q=[2.5, 97.5])} \\
Werte der Quantile eines Datensatz anzeigen \\
In diesem Beispiel die 2.5\%- und 97.5\%-Quantile \\

\pythoninline{np.sum(arr > x)} \\
Werte grösser als \textit{x} in einem Array zählen \\

\pythoninline{arr = np.cumsum(arr)} \\
Kumulative Summe des Array \textit{arr} berechnen\\

\pythoninline{np.nanmean(arr)} \\
Mittelwert berechnen und NaN ignorieren \\

\pythoninline{np.tile(arr, x)} \\
Array \textit{x}-Mal wiederholen und aneinander hängen \\

\pythoninline{np.repeat(["M1","M2","M3"], [x1, x2, x3])} \\
Jeder Werte des Array mit Index $i$, $x_i$-mal wiederholen \\

\pythoninline{np.corrcoef(arr_x, arr_y)} \\
Korrelationsmatrix berechnen

\subsection*{Numpy Zufallszahlen}

\pythoninline{arr = np.random.choice(arr, size=1000)} \\
Neues Array mit der Grösse \textit{size} erstellen und zufällig \\
mit Werten aus dem übergebenen Array befüllen \\

\pythoninline{arr = np.arange(1, 25)} \\
\pythoninline{np.random.choice(arr, 24, replace=False)} \\
Zahlen zufällig sortieren \\
In diesem Beispiel die Zahlen 1 bis 24 \\

\pythoninline{np.random.seed(35)} \\
Zufallszahlengenerator mit einem Wert initialisieren \\

\pythoninline{np.random.seed()} \\
Wert des Zufallszahlengenerator wieder löschen \\

\pythoninline{np.random.normal(size=1000)} \\
\textit{size} Standard-Normalverteilte Zufallszahlen generieren

\subsection*{Pandas Series}
\begin{python}
series = pd.Series([79.98, 80.04, 80.02])
series = pd.Series(
  [1, 5, 9, 15, 20],
  index=("mo", "di", "mi", "do", "fr")
)
\end{python}

\pythoninline{series.sum()}: Die Summe der Elemente von \textit{series} \\
\pythoninline{series.prod()}: Das Produkt der Elemente von \textit{series} \\
\pythoninline{series.mean()}: Der Durchschnitt der Elemente von \textit{series} \\
\pythoninline{series.median()}: Der Median der Elemente von \textit{series} \\
\pythoninline{series.var()}: Die Varianz der Elemente von \textit{series} \\
\pythoninline{series.std()}: Standardabweichung von \textit{series} \\
\pythoninline{series.count()}: Anzahl Elemente der \textit{series} \\
\pythoninline{series.round(x)}: Werte auf \textit{x} Nachkomastellen runden \\
\pythoninline{series.index}: Zeilenbeschrift der Elemente von \textit{series} \\
\pythoninline{series.size}: Die Anzahl der Elemente von \textit{series} \\
\pythoninline{series[1]}: Zugriff auf ein Elemente via Index \\
\pythoninline{series["mi"]}: Zugriff via Zeilenbeschrift

\subsection*{Quantile und Quartilsdifferenz}
\pythoninline{series.quantile(q=0.25, interpolation="midpoint")}
Quantile (z.B. 25\%, 75\%, \dots) von \textit{series} berechnen \\

\pythoninline{q75, q25 = series.quantile(q = [.75, .25], }\\
\pythoninline{	interpolation="midpoint")} \\
\pythoninline{iqr = q75 - q25} \\
Quartilsdifferenz von series berechnen

\subsection*{Werte einlesen}
\pythoninline{np.loadtxt(r"./data.txt")} \\
Daten für ein Array aus einem Textfile laden \\

\pythoninline{frame = pd.read_csv(r"./data.csv", } \\
\pythoninline{	sep=",", index_col=0)} \\
Werte für eine Frame aus einem CSV auslesen \\

\pythoninline{pd.read_table(r"./gamma.txt", } \\
\pythoninline{	delim_whitespace=True)} \\
leerzeichengetrennte Daten einlesen mit Pandas

\subsection*{Pandas DataFrame}
\begin{python}
frame = pd.DataFrame({
  "Luzern": ([1, 5, 9, 15, 20]),
  "Basel": ([3, 4, 12, 16, 18]),
  "Zuerich": ([8, 6, 10, 17, 23])
  }, index=["jan", "feb", "mar", "apr", "mai"]
)
\end{python}

\pythoninline{frame.columns}: Spaltenname auslesen \\
\pythoninline{frame.shape}: Anzahl Zeilen und Spalten des Frames \\
\pythoninline{frame.T}: Zeilen und Spalten vertauschen \\
\pythoninline{frame.describe()}: Kennzahlen jeder Spalte anzeigen \\
\pythoninline{frame.mean(axis=0)}: Durchschnitt pro Spalte berechnen \\
\pythoninline{frame.mean(axis=1)}: Durchschnitt pro Zeile berechnen \\
\pythoninline{frame.head(n)}: Erste \textit{n} Zeilen des Frames anzeigen \\
\pythoninline{frame.tail(n)}: Letzte \textit{n} Zeilen des Frames anzeigen \\
\pythoninline{frame.index}: Zeilenbeschriftung des Frames anzeigen \\
\pythoninline{frame.drop(x, 0)}: Zeile mit dem Index \textit{x} löschen \\
\pythoninline{frame.drop(x, 1)}: Spalte \textit{x} löschen \\
\pythoninline{frame.corr()}: Korrelationsmatrix berechnen

\subsection*{Umgang mit DataFrame}
\pythoninline{copy = frame.copy()} \\
Kopie eines DataFrame erstellen \\

\pythoninline{frame.loc["mar":"mai","Luzern"]} \\
Auf einen Bereiche in einem DataFrame zugreifen \\

\pythoninline{frame.loc[["mar","mai"],["Basel","Zuerich"]]} \\
Auf ausgewählt Elemente in einem DataFrame zugreifen \\

\pythoninline{frame.sort_values(by='Luzern', ascending=False)} \\
Daten im Frame nach einer Spalte sortieren \\

\pythoninline{frame.nsmallest(n, 'Luzern')} \\
\pythoninline{frame.nlargest(n, 'Luzern')} \\
Daten im Frame nach einer Spalte sortieren und dann \\
\textit{n} Zeilen mit grösstem oder kleinstem Werte zurückgeben \\

\pythoninline{filtered = frame[frame['Luzern'] == 0]} \\
Daten anhand des Wertes einer Spalte filtern \\

\pythoninline{mean = frame.mean()['Luzern']} \\
\pythoninline{frame.loc[frame['Luzern'] < mean, 2:5]} \\
Daten anhand des Wertes einer Spalte filtern und die \\
Zeilen einschränken (in diesem Beispiel 2 bis 5)

\begin{tcolorbox}[boxrule=1pt,colback=black!4!white, title=\underline{\textbf{DataFrame für die nächsten Befehle}},colframe=black!4!white,coltitle=black]
	\begin{python}
df=DataFrame({
  "Behandlung": np.repeat(
    ["A", "B", "C", "D"],
    [4, 6, 6, 8]
  ),
  "Koagulationszeit":
    [62, 60, 63, 59, 63, 67, 71, ...]
})
	\end{python}
\end{tcolorbox}

\pythoninline{df_group = df.groupby('Behandlung')} \\
DataFrame nach Spaltenwerte gruppieren\\
\pythoninline{df_group.get_group('A')} \\
Auf gleiche Gruppe zugreifen\\
\pythoninline{df_group.get_group('A')['Koagulationszeit']}\\
Auf die Werte der Gruppe zugreifen

\subsection*{Matplotlib PyPlot}
\pythoninline{plt.title("...")}: Titel des Plots festlegen \\
\pythoninline{plt.xlabel("...")}: X-Achsenbeschriftung festlegen \\
\pythoninline{plt.ylabel("...")}: Y-Achsenbeschriftung festlegen \\
\pythoninline{plt.show()}: Plot anzeigen \\
\pythoninline{plt.tight_layout()}: vermeiden, dass Beschriftungen in Diagrammen enden \\

\pythoninline{plt.subplot(nrows=2, ncols=3, index=4)} \\
\pythoninline{plt.subplot(234)} \\
Sub-Plot mit 2 Zeilen und 3 Spalten erstellen und den \\
nächsten Plot an der Position 4 einfügen. Die Position wird \\
von links nach rechts und dann von oben nach unten gezählt

\subsection*{Plots erstellen}
\pythoninline{series.hist(bins=[0, 1, 10, 11, 12])} \\
Histogramm mit angegebenen Klassengrenzen plotten \\

\pythoninline{series.plot(kind="hist", edgecolor="black")} \\
Histogramm erstellen und Balken mit Farbe umrahmen \\

\pythoninline{series.plot(kind="hist", density=True, ...)}
Normiertes Histogramm erstellen, bzw. Fläche des Histogramms auf eins normieren\\

\pythoninline{series.plot(kind="hist", bins=20, ...)} \\
Anzahl Klassen des Histogramm manuell festlegen \\

\pythoninline{series.plot(kind='hist', cumulative=True,
	histtype='step', density=True)} \\
Empirische kumulative Verteilungsfunktion plotten \\

\pythoninline{series.plot(kind='box', title='Methode A')} \\
Boxplot von \textit{series} erstellen und Titel des Plots festlegen \\

\pythoninline{frame.boxplot("T", by="Time")} \\
Daten gruppieren und durch einen Boxplot anzeigen

\pythoninline{frame.plot(kind='scatter', x='wine', y='mor')} \\
Streudiagramm mit zwei ausgewählten Achsen erstellen \\
Parameter \textit{x} und \textit{y} müssen auf Indizes des \textit{frame} verweisen \\

\pythoninline{b, a = np.polyfit(x_series, y_series, deg=1)} \\
\pythoninline{x = np.linspace(x_series.min(), x_series.max())} \\
\pythoninline{plt.plot(x, a + b * x, c='orange')} \\
Plotten einer Regressionsgerade, bei welcher die Daten \\
einem Polynom ersten Grades angeglichen wurden \\

\pythoninline{st.probplot(arr, plot=plt)} \\
QQ-Plot anhand einer Normalverteilung\\

\pythoninline{t = np.linspace(start, stop, amount_of_numbers)}\\
\pythoninline{plt.plot(t, f(t), linewidth=1.0)}\\
Kurve der Funktion f(t) im Intervall [\pythoninline{start,stop}] plotten

% TODO Remove, just for layout purposes
\vfill\null
\columnbreak

\subsection*{Mehrere DataFrame Plots in einem MatPlotLib}

\begin{tcolorbox}[boxrule=1pt,colback=black!4!white, title=\underline{\textbf{Struktur der Daten für die nächsten Befehle}},colframe=black!4!white,coltitle=black]
	\begin{verbatim}
	"high" "medium" "low"
	0.71 2.2 2.25
	1.66 2.93 3.93
	2.01 3.08 5.08
	...
	\end{verbatim}
\end{tcolorbox}

\begin{python}
plt.figure(1)
plt.subplot(1,3,1)
iron.low.plot(kind='box')
plt.subplot(1,3,2)
iron.medium.plot(kind='box', ax=plt.gca())
plt.subplot(1,3,3)
iron.high.plot(kind='box', ax=plt.gca())
plt.tight_layout()
plt.show()
\end{python}

\subsection*{Verteilungen}
\pythoninline{cdf}: Kumulative Verteilungsfunktion $P(X \leq x)$ \\
\pythoninline{ppf}: Quantile der Verteilung $\alpha_q$ \\
\pythoninline{pdf}: Dichte an der Stelle $x$ \\
\pythoninline{pmf}: Punktw'keit an der Stelle $P(X=x)$ \\
\pythoninline{rvs}: $size$ Zufallszahlen generieren

\subsubsection*{Uniformverteilung}

\pythoninline{st.uniform.cdf(x=1, loc=4, scale=5)} \\
$P(X \leq 1)$ falls $X \sim Unif(4, 9)$ \\
\colorbox{red!20!white}{\pythoninline{scale} ist nicht Endwert, sondern Länge des Intervall}\\

\pythoninline{st.uniform.pdf(x=1, loc=0, scale=7)} \\
Dichte an der Stelle \textit{x} = 1 falls $X \sim Unif(0, 7)$

\subsubsection*{Binom-, Exponential- und Poissonverteilung}

\pythoninline{st.binom.cdf(k=5100, n=10000, p=0.5)} \\
$P(X \leq 5100)$ falls $X \sim Bin(10000, 0.5)$ \\

\pythoninline{st.binom.pmf(k=1000, n=1000, p=0.5)} \\
Wert der Wahrscheinlichkeitsdichtefunktion an der Stelle $k$ \\

\pythoninline{st.expon.cdf(x=4, loc=0, scale=1/3)} \\
$P(X \leq 4)$ falls $X \sim e^{3}$ \\
\colorbox{red!20!white}{\pythoninline{scale} muss mit $\frac{1}{\lambda}$ angegeben werden}\\

\pythoninline{st.expon.pdf(x=1, loc=0, scale=1/3)} \\
Dichte an der Stelle \textit{x} = 1 falls $X \sim e^{3}$ \\

\pythoninline{st.poisson.pmf(mu=1.5, k=2)} \\
$P(X = 2)$ falls $X \sim Pois(1.5)$

\subsubsection*{Normalverteilung}

\pythoninline{st.norm.cdf(x=130, loc=100, scale=15)} \\
$P(X \leq 130)$ falls $X \sim \mathcal{N}(100, 15^2)$

\pythoninline{st.norm.ppf(q=0.05, loc=100, scale=15)} \\
5\% Quantile falls $X \sim \mathcal{N}(100, 15^2)$ \\

\pythoninline{st.norm.cdf(x=1.5)} \\
$P(X \leq 1.5)$ falls $X \sim \mathcal{N}(0, 1^2)$

\subsubsection*{T Verteilung}

\pythoninline{st.t.cdf(x=168, df=149, loc=164, } \\
\pythoninline{	scale=10/np.sqrt(150))} \\
$P[\overline{X}_{150} \leq 168]$ falls $u = 164$, $\hat{o} = 10$ und $T \sim t_{149}$ (150 Messungen - 1 geschätzter Parameter) \\

\pythoninline{st.t.ppf(0.05, df=v)} \\
Quantile einer T-Verteilung mit \textit{v} Freiheitsgrade

\subsubsection*{F Verteilung}
\pythoninline{st.f.cdf(x=F, dfn=DF_G, dfd=DF_E)}\\
Kumulative Wahrscheinlichkeitsverteilung mit $F=\frac{MS_G}{MS_E}$, $DF_G = g - 1$, $DF_E = n - g$ und $n = m\cdot g$\\

\pythoninline{st.f.ppf(q=0.95, dfn=DF_G, dfd=DF_E)}\\
95\% Perzentil mit $DF_G = g - 1$, $DF_E = n - g$ und $n = m\cdot g$

\subsubsection*{Generierung zufallsverteilter Zahlen}

\pythoninline{st.norm.rvs(size=n)}\\
\textit{n} normalverteilte Zahlen \\

\pythoninline{st.uniform.rvs(size=3, loc=0, scale=7)} \\
uniform verteilte Zufallszahlen, $X_i \sim Unif(0, 7)$ \\

\pythoninline{st.t.rvs(size=n, df=v)} \\
generiert \textit{n} t-verteilte Zahlen mit \textit{v} Freiheitsgrade \\

\pythoninline{st.chi2.rvs(size=n, df=v)} \\
generiert \textit{n} chi-verteilte Zahlen mit \textit{v} Freiheitsgrade

\subsection*{Integral berechnen}
\pythoninline{from scipy.integrate import quad} \\
\pythoninline{f = lambda x: x * (15 - x/4)} \\
\pythoninline{ans, _ = quad(f, 0, 60)} \\
In diesem Fall das Integral: $\int_{0}^{60} x * (15 - \frac{x}{4})$

\subsection*{Gleichung lösen}
\pythoninline{from sympy.solvers import solve} \\
\pythoninline{from sympy import Symbol} \\
\pythoninline{x = Symbol('x')} \\
\pythoninline{solve(x**2/9000 * (15/2 - x/12) - 0.9, x)} \\
Löst die Gleichung: $\frac{x^2}{9000} (\frac{15}{2} - \frac{x}{12}) - 0.9 = 0$

\subsection*{Vertrauensintervall}
\pythoninline{st.t.interval(alpha=0.95, df=12, loc=80.02, } \\
\pythoninline{	scale=0.024/np.sqrt(13))} \\
95\% Vertrauensintervall einer t-Verteilung \\
wenn $n=13$, $\sigma=0.024$ und $u=80.02$ \\

\pythoninline{st.norm.interval(alpha=0.99, loc=31, } \\
\pythoninline{	scale=6/np.sqrt(10))} \\
99\% Vertrauensintervall falls $X \sim \mathcal{N}(31, 6 / \sqrt{10})$

% TODO Remove, just for layout purposes
\vfill\null
\columnbreak

\subsection*{Statistische Tests}
\pythoninline{st.binom_test(x=3, n=5, p=0.5,} \\
\pythoninline{	alternative='two-sided')}\\
Vorzeichentest mit \textit{x} Erfolge bei \textit{n} Versuchen
und einer Erfolgswahrscheinlichkeit von 50\%
\vspace{0.5em}\\
\pythoninline{alternative} : \{'two-sided', 'greater', 'less'\}, \textbf{optional}\\
Angabe der Alternativhypothese. Der Standardwert ist 'two-sided'.\\

\subsubsection*{Wilcoxon-Test}
\pythoninline{st.wilcoxon(x_arr,y_arr, zero_method="wilcox",}\\
\pythoninline{	correction=True)}\\
Berechnet den Wilcoxon Vorzeichenrangtest der Differenz zwischen den beiden Serien \pythoninline{x_arr} und \pythoninline{y_arr}\\

\pythoninline{st.wilcoxon(arr, zero_method="wilcox",}\\
\pythoninline{	correction=True)}
Berechnet den Wilcoxon Vorzeichenrangtest, erwartet das \pythoninline{arr} schon die Differenz zweier Serien beinhaltet
\vspace{0.5em}\\
\pythoninline{zero_method} : \{"pratt", "wilcox", "zsplit"\}, \textbf{optional}\\
"wilcox": Wilcox treatment: discards all zero-differences
\vspace{0.5em}\\
\pythoninline{st.wilcoxon(arr, zero_method="wilcox",}\\
\pythoninline{	correction=True).pvalue} \\
Auf den p-Value des Wilcoxontests zugreifen\\

\subsubsection*{t-Test}
\pythoninline{st.ttest_rel(series1, series2)} \\
Statistischer Test für gepaarte Stichproben  \\

\pythoninline{st.ttest_ind(series1, series2, equal_var=False)} \\
Statistischer Test für ungepaarte Stichproben  \\

\pythoninline{st.ttest_1samp(series, 1).pvalue} \\
P-Wert eines T-Tests für eine Series berechnen \\
mit der Nullhypothese $u=1$ \\
\colorbox{red!20!white}{\pythoninline{pvalue} ist der P-Wert des zweiseitigen Tests}\\

\subsubsection*{Mann-Whitney U-Test}
\pythoninline{st.mannwhitneyu(series1, series2,}\\
\pythoninline{	alternative='two-sided')} \\
Mann-Whitney U-Test (aka Wilcoxon Rank-sum Test) \\


\subsection*{Varianzanalyse}
\pythoninline{from statsmodels.graphics.factorplots} \\
\pythoninline{	import interaction_plot} \\
\pythoninline{from statsmodels.stats.anova import anova_lm} \\
\pythoninline{from statsmodels.formula.api import ols} \\
\pythoninline{from patsy.contrasts import Sum} \\
Benötigte Bibliotheksfunktionen für Varianzanalysen

\pythoninline{sns.stripplot(x="...", y="...", data=frame)} \\
Varianz-Analyse mit Stripcharts zwischen \textit{x} und \textit{y} \\

\pythoninline{sns.boxplot(x="...", y="...", data=frame)} \\
Varianz-Analyse mit Boxplots zwischen \textit{x} und \textit{y} \\

\pythoninline{sns.distplot(Fstat, kde=False, norm_hist=True,
	hist_kws=dict(edgecolor="black", linewidth=2))} \\
F-Statistik plotten \\

\pythoninline{sns.boxplot(series.index.weekday, series)} \\
\pythoninline{sns.boxplot(series.index.month, series)} \\
\pythoninline{sns.boxplot(series.index.quarter, series)} \\
\pythoninline{sns.boxplot(series.index.year, series)} \\
Boxplot für gruppierte Daten nach Wochentag, Monat, \\
Quartal, Jahr, ... anzeigen \\
\colorbox{red!20!white}{\pythoninline{series} muss ein DatetimeIndex haben}\\

\begin{tcolorbox}[boxrule=1pt,colback=black!4!white, title=\underline{\textbf{DataFrame für die nächsten Befehle}},colframe=black!4!white,coltitle=black]
\begin{python}
frame = pd.DataFrame({
  "Treatment": np.repeat(["Vak","CO2"], 3),
  "steak_id":[7.66, 6.98, 7.80, 5.26, ...]
})
\end{python}
\end{tcolorbox}

\pythoninline{fit = ols("steak_id~Treatment", data=frame).fit()} \\
\pythoninline{fit.summary()} \\
Gruppenmittelmodell berechnen zwischen der Id des \\
Steaks und der ausgeführten Behandlung \\

\pythoninline{fit_pred = fit.get_prediction()} \\
\pythoninline{fit_pred.conf_int()} \\
Vertrauensintervalle für Gruppenmittelwerte \\

\pythoninline{anova_lm(fit)} \\
Anova Tabelle berechnen

\begin{tcolorbox}[boxrule=1pt,colback=black!4!white, title=\underline{\textbf{DataFrame für die nächsten Befehle}},colframe=black!4!white,coltitle=black]
\begin{python}
frame = pd.DataFrame({
  "Batch": np.tile(["1", "2", "3"], 4),
  "Methode": np.repeat(["8500", "9100"], 6),
  "Y": np.array([90.3, 89.2, 98.2, ...])
})
\end{python}
\end{tcolorbox}

\pythoninline{interaction_plot(x=frame["Batch"], }\\
\pythoninline{	trace=frame["Methode"], response=frame["Y"])} \\
Interaktionsplot erstellen \\
- entlang der y-Achse die Zielgrösse (response) \\
- entlang der x-Achse der durch x festgelegte Faktor \\
- für jede Stufe in trace wird dann eine Linie gezogen \\

\pythoninline{formula = "Y ~ C(Methode, Sum) + C(Batch, Sum)"} \\
\pythoninline{fit = ols(formula, data=frame).fit()} \\
Zweiweg-Varianzanalyse mit Blöcken zwischen den \\
Datenspalten \textit{Methode} und \textit{Batch} \\

\begin{tcolorbox}[boxrule=1pt,colback=black!4!white, title=\underline{\textbf{DataFrame für die nächsten Befehle}},colframe=black!4!white,coltitle=black]
\begin{python}
frame = pd.DataFrame({
  "Konz": np.repeat(["A", "B", "C","D"], 6),
  "Temp": np.tile(np.repeat(["1", "2"],3),4),
  "Y": np.array([82, 46, 16, 20, 13, ...])
})
\end{python}
\end{tcolorbox}

\pythoninline{formula = "Y ~ C(Konz, Sum) * C(Temp, Sum)"} \\
\pythoninline{fit = ols(formula, data=frame).fit()} \\
Faktorielle Experimente mit den zwei \\
Faktoren \textit{Konzentration} und \textit{Temperatur}\\

% TODO Remove, just for layout purposes
\vfill\null
\columnbreak


\subsection*{Zeitreihen}
\pythoninline{from statsmodels.tsa.seasonal } \\
\pythoninline{	import seasonal_decompose} \\
Benötigte Bibliotheksfunktionen für Zeitreihen \\

\begin{tcolorbox}[boxrule=1pt,colback=black!4!white, title=\underline{\textbf{DataFrame für die nächsten Befehle}},colframe=black!4!white,coltitle=black]
	\begin{verbatim}
	TravelDate  Passengers
	0   1/1/1949         112
	1   2/1/1949         118
	2   3/1/1949         132
	3   4/1/1949         129
	4   5/1/1949         121
	.   ........         ...
	\end{verbatim}
\end{tcolorbox}

\pythoninline{def boxcox(frame, lambd):} \\
\pythoninline{	return np.log(frame) if (lambd == 0)\} \\
\pythoninline{		else (frame**lambd - 1) / lambd} \\
BoxCox-Funktion definieren \\

\pythoninline{series = frame["Passengers"].shift(-5)} \\
Zeitverschiebung (shifting) mit $k = -5$ \\

\pythoninline{col = frame["TravelDate"]} \\
\pythoninline{frame["TravelDate"] = pd.DatetimeIndex(col)} \\
\pythoninline{frame.set_index("TravelDate", inplace=True)} \\
Datums-Index einer Zeitreihe setzen \\

\pythoninline{frame["Passengers"].rolling(window=12).mean()} \\
Bewegendes Mittel (moving average) berechnen \\
bei einer Fenstergrösse von 12 \\

\pythoninline{seasonal_decompose(frame["Passengers"], } \\
\pythoninline{	model="additive", freq=12).plot()} \\
Zerlegen einer Zeitreihe in die verschiedenen Faktoren \\
bei einer Fenstergrösse von 12 \\

\pythoninline{seasonal_decompose(np.log(frame["Passengers"]),} \\
\pythoninline{	model="add").resid.plot()} \\
Residuen Plot von logarithmierten Daten anzeigen \\

% TODO Remove, just for layout purposes
\vfill\null
\columnbreak

\pythoninline{seasonal_decompose(frame["Passengers"], } \\
\pythoninline{	model="mul").plot()} \\
Zerlegen einer Zeitreihe mit dem multiplikativen Modell \\

\pythoninline{frame.resample("A").mean()} \\
Zeitreihe so umformen, dass jede Zeile den \\
Jahresdurchschnitt eines Jahres enthält

\subsection*{Autoregressive Modelle}

\pythoninline{from statsmodels.graphics.tsaplot } \\
\pythoninline{	import plot_acf, plot_pacf} \\
\pythoninline{from statsmodels.tsa.arima_model} \\
\pythoninline{	import ARMA, ArmaProcess} \\
Benötigte Bibliotheksfunktionen für Autoregressive Modelle

\pythoninline{plot_acf(frame, lags=50)} \\
Prüft ob ein Autoregressives modell angebracht ist \\

\pythoninline{plot_pacf(frame, lags=50)} \\
Findet den parameter $p$ heraus (grösste nicht im \\
Weissen Rauschen verschwindender Wert) \\

\pythoninline{model = ARMA(frame, order=(p, 0).fit()} \\
Erstellt ein autoregressives Modell mit parameter $p$ \\

\pythoninline{frame.plot()} \\
\pythoninline{(frame["Passengers"] - model.resid).plot()} \\
Vergleich zwischen Daten und Modell \\

\pythoninline{fig, ax = plt.subplots()} \\
\pythoninline{ax = frame.plot(ax=ax)} \\
\pythoninline{model.plot_predict("start", "end",} \\
\pythoninline{	dynamic=True, ax=ax, plot_insample=True)} \\
Vorhersagen des Modells erstellen \\

\pythoninline{process = ArmaProcess([a_1, a_2, ...], ma=[1])} \\
Erstellen eines theoretischen autoregressiven Prozesses \\
$a_n$, stellt die polynomialparameter dar \\

% TODO Remove, just for layout purposes
\vfill\null
\columnbreak

\subsection*{Allgemein}
\pythoninline{from scipy.special import comb} \\
\pythoninline{comb(N=5, k=3, exact=True)} \\
Binomialkoeffizient berechnen, in diesem Beispiel $\binom{5}{3}$ \\

\pythoninline{import warnings} \\
\pythoninline{warnings.filterwarnings('ignore')} \\
Python-Warnungen ausblenden \\

\pythoninline{import matplotlib} \\
\pythoninline{matplotlib.rcParams['figure.dpi'] = 150} \\
Plot grösser machen (für High-DPI-Screens) \\

\pythoninline{%matplotlib inline} \\
Plots in Jupyter-Notebook direkt anzeigen

\end{multicols*}
\end{document}

